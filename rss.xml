<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title></title>
        <link>undefined</link>
        <description>undefined</description>
        <lastBuildDate>Sun, 26 May 2024 13:11:37 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>Joplin Pages Publisher</generator>
        <item>
            <title><![CDATA[type switch]]></title>
            <guid>30535fb6c2484331a412c765ce375acc</guid>
            <pubDate>Fri, 02 Jun 2023 02:39:53 GMT</pubDate>
            <content:encoded><![CDATA[<p>针对 <code>interface{}</code> 类型的变量，我们需要针对这个变量真实的类型进行转换、处理，则可使用 <code>type switch</code> 进行进行判断、处理，如下：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"fmt"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">var</span> i <span class="hljs-keyword">int</span>
    fmt.Println(checkType(i))
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkType</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>{})</span> <span class="hljs-title">string</span></span> {
    <span class="hljs-comment">// i 参数为 interface{}, 可以传递任意类型</span>
    
    <span class="hljs-comment">// 通过 switch type 的形式，来进行类型判断</span>
    <span class="hljs-comment">// 用于针对变量类型不确定情况下，按照不同类型进行对应不同行为处理的场景</span>
    <span class="hljs-keyword">switch</span> i.(<span class="hljs-keyword">type</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-keyword">string</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"string"</span>	
    <span class="hljs-keyword">case</span> <span class="hljs-keyword">int</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"int"</span>
    <span class="hljs-keyword">case</span> <span class="hljs-keyword">bool</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"bool"</span>
    <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"unknown"</span>
    }
}</code></pre></div>
<hr />
<p>针对已知类型，可直接使用 <code>i.(类型)</code> 进行转换，例如：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"fmt"</span>
)

<span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span> {
    SayName() <span class="hljs-keyword">string</span>
}

<span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> {
    Name <span class="hljs-keyword">string</span>
}

<span class="hljs-comment">// User 实现了 I 接口</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u User)</span> <span class="hljs-title">SayName</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> {
    <span class="hljs-keyword">return</span> u.Name
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u User)</span> <span class="hljs-title">SayHello</span><span class="hljs-params">()</span></span> {
    fmt.Println(<span class="hljs-string">"hello"</span>)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// 此时 i 类型是 I</span>
    <span class="hljs-keyword">var</span> i I = User{
        Name: <span class="hljs-string">"user"</span>,
    }

    call(i) <span class="hljs-comment">// 正常输入，因为 i 实现了 I 接口</span>

    <span class="hljs-comment">// i.SayHello() // 直接执行 i.SayHello() 报错，因为 I 接口无 SayHello() 方法</span>

    <span class="hljs-comment">// 使用 变量.(类型) 进行转换后，b 类型为 User{}, 可进行 SayHello()</span>
    b := i.(User)

    b.SayHello()
    
    i = i.(User)
    i.SayHello() <span class="hljs-comment">// 也会报错，因为 i 的类型最开始就已经限定了是 I</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">call</span><span class="hljs-params">(i I)</span></span> {
    fmt.Println(i.SayName())
}
</code></pre></div>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[pyenv]]></title>
            <guid>5851f365c51f4663aab547992ef4e9dc</guid>
            <pubDate>Mon, 28 Nov 2022 02:26:49 GMT</pubDate>
            <content:encoded><![CDATA[<h2 id="pyenv">pyenv</h2>
<p>!!! note 简述<br />
<code>pyenv</code> 就是 python 语言的多版本管理工具，类似于 <a title="https://www.npmjs.com/package/n" href="https://www.npmjs.com/package/n">Node.js 的 <code>n</code></a>。<br />
!!!</p>
<h3 id="安装-pyenv">安装 pyenv</h3>
<div><pre class="hljs"><code><span class="hljs-meta">
$ </span><span class="language-bash">brew install pyenv</span>
<span class="hljs-meta">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">'export PYENV_ROOT="$HOME/.pyenv"'</span> &gt;&gt; ~/.bash_profile</span>
<span class="hljs-meta">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">'export PATH="$PYENV_ROOT/bin:$PATH"'</span> &gt;&gt; ~/.bash_profile</span>
<span class="hljs-meta">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> -e <span class="hljs-string">'if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then\n  eval "$(pyenv init -)"\nfi'</span> &gt;&gt; ~/.bash_profile</span>
<span class="hljs-meta">
$ </span><span class="language-bash">bash <span class="hljs-comment"># .bash_profile 生效</span></span></code></pre></div>
<h3 id="安装需要版本的-python">安装需要版本的 Python</h3>
<div><pre class="hljs"><code>安装需要版本的 python
<span class="hljs-meta">$ </span><span class="language-bash">pyenv install 3.6.4</span></code></pre></div>
<h3 id="激活已安装的-python">激活已安装的 Python</h3>
<div><pre class="hljs"><code><span class="hljs-meta">$ </span><span class="language-bash">pyenv <span class="hljs-built_in">local</span> 3.6.4</span></code></pre></div>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[async / await]]></title>
            <guid>edb2b1ba32ef469896edbf2eeebe9171</guid>
            <pubDate>Sun, 27 Nov 2022 13:50:30 GMT</pubDate>
            <content:encoded><![CDATA[<h2 id="async-await">async / await</h2>
<blockquote>
<p><code>async</code> / <code>await</code> 是未来，<code>@asyncio.coroutine</code> / <code>yield from</code> 是历史。</p>
</blockquote>
<hr />
<p>进程、线程、协程的区别：</p>
<p>进程是独立的进程，有自己的命名空间执行，可以 ps aux 看到<br />
一个进程可有多个线程去执行，由操作系统来决定进行线程执行状态切换，不能通过 ps aux 看到线程<br />
协程是由用户手动控制的执行在线程中的逻辑，占用资源更小，执行效率更快（因为不需要频繁切换进程、线程），但是有一定的开发能力的要求。</p>
<p>最早，在 <code>Node.js</code> 等语言中，都是使用了 <code>yield</code> / <code>yield from</code> 等方式来做到协程的，后续增加了语法糖：<code>async</code> / <code>await</code> 用于协程开发。</p>
<hr />
<p>python 中一个简单的例子：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> asyncio

<span class="hljs-comment"># 引入 asyncio 启动了异步语法糖工具</span>

<span class="hljs-comment"># 标示为一个异步协程函数</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'hello world'</span>)
    <span class="hljs-comment"># 等待 asyncio.sleep(1)</span>
    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'hello again!'</span>)

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">r</span>():
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):
        <span class="hljs-built_in">print</span>(i)
        <span class="hljs-keyword">await</span> hello()

<span class="hljs-comment"># 启动异步 event_loop</span>
loop = asyncio.get_event_loop()
<span class="hljs-comment"># 执行等待完成</span>
loop.run_until_complete(r())
loop.close()</code></pre></div>
<p>python3 中如果看到了 <code>@asyncio.coroutine</code> 和 <code>yield from</code> 同时出现，可以考虑脑补为 <code>async</code> / <code>await</code></p>
<p>如上脚本可修改为：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">import</span> asyncio

<span class="hljs-meta">@asyncio.coroutine</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'hello world'</span>)
    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> asyncio.sleep(<span class="hljs-number">1</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'hello again!'</span>)

<span class="hljs-meta">@asyncio.coroutine</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">r</span>():
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):
        <span class="hljs-built_in">print</span>(i)
        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> hello()

loop = asyncio.get_event_loop()
loop.run_until_complete(r())
loop.close()</code></pre></div>
<p>在 <code>Python3.8</code> 中会提示 <code>@coroutine" decorator is deprecated</code>。Python3.8 开始，废弃掉了 <code>@asyncio.coroutine</code> 写法。</p>
]]></content:encoded>
        </item>
    </channel>
</rss>